<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nihan Programming - Ultra Realism</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #e8e8e8; /* Slight texture look */
            background-image: radial-gradient(#d0d0d0 1px, transparent 1px);
            background-size: 20px 20px;
            font-family: 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
        h1 {
            margin: 0;
            font-size: 24px;
            color: #333;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        p {
            margin: 5px 0;
            font-size: 14px;
            color: #555;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>Nihan Bio-Sim v3.0</h1>
    <p>System: Tripod Gait & Idle Behavior Active</p>
    <p>Interaction: Mouse to Attract | Click to Scare</p>
</div>

<canvas id="simCanvas"></canvas>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    let w, h;
    const ants = [];
    const ANT_COUNT = 80; // Fewer ants, but higher quality
    
    // Mouse state
    const mouse = { x: -9999, y: -9999, click: false };

    // Resize setup
    function resize() {
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
    }
    window.addEventListener('resize', resize);
    resize();

    // Input listeners
    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });
    window.addEventListener('mousedown', () => {
        mouse.click = true;
        setTimeout(() => mouse.click = false, 500);
    });

    // --- UTILITIES ---
    const random = (min, max) => Math.random() * (max - min) + min;

    // --- THE BIOLOGICAL ANT CLASS ---
    class Ant {
        constructor() {
            this.init();
        }

        init() {
            this.x = random(0, w);
            this.y = random(0, h);
            this.angle = random(0, Math.PI * 2);
            this.targetAngle = this.angle;
            this.size = random(0.8, 1.2); // Size variation
            
            // Movement Physics
            this.speed = 0;
            this.maxSpeed = random(1.5, 2.5);
            this.acceleration = 0.05;
            
            // State Machine: 'WALK' or 'IDLE'
            this.state = 'WALK';
            this.stateTimer = random(100, 500);

            // Animation Properties
            this.walkCycle = 0;
            this.antennaOffset = 0;
        }

        update() {
            // 1. State Management (Stop and Go behavior)
            this.stateTimer--;
            if (this.stateTimer <= 0) {
                if (this.state === 'WALK') {
                    // Switch to IDLE (Stop to look around)
                    this.state = 'IDLE';
                    this.stateTimer = random(50, 150);
                    this.speed = 0; // Immediate stop mechanism
                } else {
                    // Switch to WALK
                    this.state = 'WALK';
                    this.stateTimer = random(200, 600);
                }
            }

            // 2. Interaction Logic
            let dx = mouse.x - this.x;
            let dy = mouse.y - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let fearFactor = false;

            if (mouse.click && dist < 300) fearFactor = true; // Panic mode

            if (fearFactor) {
                // Run away fast
                this.state = 'WALK'; // Force walk
                this.targetAngle = Math.atan2(dy, dx) + Math.PI;
                this.speed = this.maxSpeed * 2.5;
            } else if (dist < 200 && this.state === 'WALK') {
                // Attract to mouse
                this.targetAngle = Math.atan2(dy, dx);
            } else if (this.state === 'WALK') {
                // Random wandering wiggle
                if (Math.random() < 0.05) {
                    this.targetAngle += random(-1, 1);
                }
            }

            // 3. Physics & Smooth Rotation
            if (this.state === 'WALK' || fearFactor) {
                // Smooth acceleration
                if (this.speed < this.maxSpeed) this.speed += this.acceleration;
                
                // Smooth rotation
                let diff = this.targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * 0.1;

                // Move
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // Animate Legs (Speed dependent)
                this.walkCycle += this.speed * 0.2;
            } else {
                // Decelerate to 0
                this.speed *= 0.8; 
            }

            // Antennae always twitch
            this.antennaOffset += 0.5;

            // Screen Wrap
            if (this.x < -20) this.x = w + 20;
            if (this.x > w + 20) this.x = -20;
            if (this.y < -20) this.y = h + 20;
            if (this.y > h + 20) this.y = -20;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle + Math.PI / 2); // Rotate to face up relative to calc
            const s = this.size;

            // Shadow (Soft blur underneath)
            ctx.fillStyle = "rgba(0,0,0,0.15)";
            ctx.beginPath();
            ctx.ellipse(0, 2*s, 3*s, 8*s, 0, 0, Math.PI*2);
            ctx.fill();

            // --- LEGS (Tripod Gait) ---
            // Real ants use tripod: Legs R1, L2, R3 move together, L1, R2, L3 support.
            ctx.strokeStyle = "#2a1a0a";
            ctx.lineWidth = 0.8 * s;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            const walkVal = this.walkCycle;
            
            // Helper for jointed legs
            const drawLeg = (side, yPos, length, phaseOffset) => {
                // Calculate movement based on phase
                const move = Math.sin(walkVal + phaseOffset) * (this.speed * 0.5);
                
                // Joint calculations (Femur & Tibia)
                const startX = (side === 'left' ? -2 : 2) * s;
                const elbowX = (side === 'left' ? -6 : 6) * s;
                const footX  = (side === 'left' ? -9 : 9) * s;
                
                // Dynamic Y positions simulating stepping
                const currentElbowY = yPos - Math.abs(move) * 2; // Knee goes up
                const currentFootY = yPos + move * 4; // Foot moves forward/back

                ctx.beginPath();
                ctx.moveTo(startX, yPos);
                ctx.lineTo(elbowX, currentElbowY); // Femur
                ctx.lineTo(footX, currentFootY);   // Tibia
                ctx.stroke();
            };

            // Right Side Legs
            drawLeg('right', -4*s, 8, 0);       // R1 (Front)
            drawLeg('right', 0, 8, Math.PI);    // R2 (Mid) - Opposite Phase
            drawLeg('right', 4*s, 9, 0);        // R3 (Back)

            // Left Side Legs
            drawLeg('left', -4*s, 8, Math.PI);  // L1 (Front) - Opposite Phase
            drawLeg('left', 0, 8, 0);           // L2 (Mid)
            drawLeg('left', 4*s, 9, Math.PI);   // L3 (Back) - Opposite Phase

            // --- BODY (Glossy Segments) ---
            const grad = ctx.createRadialGradient(-2*s, -2*s, 0, 0, 0, 10*s);
            grad.addColorStop(0, "#5e4b35"); // Highlight
            grad.addColorStop(0.5, "#2a1a0a"); // Base
            grad.addColorStop(1, "#0f0802"); // Shadow

            ctx.fillStyle = grad;

            // 1. Abdomen (Rear - Large)
            ctx.beginPath();
            ctx.ellipse(0, 5*s, 3.5*s, 5*s, 0, 0, Math.PI*2);
            ctx.fill();

            // 2. Thorax (Middle - Thin)
            ctx.beginPath();
            ctx.ellipse(0, 0, 1.8*s, 2.5*s, 0, 0, Math.PI*2);
            ctx.fill();

            // 3. Head (Front)
            ctx.beginPath();
            // Complex head shape
            ctx.moveTo(0, -6*s);
            ctx.bezierCurveTo(3*s, -6*s, 2.5*s, -2.5*s, 0, -2.5*s); // Right cheek
            ctx.bezierCurveTo(-2.5*s, -2.5*s, -3*s, -6*s, 0, -6*s); // Left cheek
            ctx.fill();

            // --- DETAILS ---
            
            // Mandibles (Jaws)
            ctx.strokeStyle = "#3e2b17";
            ctx.lineWidth = 1 * s;
            ctx.beginPath();
            ctx.moveTo(1*s, -5.5*s);
            ctx.quadraticCurveTo(2*s, -7.5*s, 0.5*s, -8*s); // Right Jaw
            ctx.moveTo(-1*s, -5.5*s);
            ctx.quadraticCurveTo(-2*s, -7.5*s, -0.5*s, -8*s); // Left Jaw
            ctx.stroke();

            // Antennae (Twitching)
            ctx.strokeStyle = "#2a1a0a";
            ctx.lineWidth = 0.5 * s;
            
            // Random twitch calculation
            const twitchL = Math.sin(this.antennaOffset * 0.8) * 0.2;
            const twitchR = Math.sin(this.antennaOffset * 0.9 + 1) * 0.2;

            ctx.beginPath();
            // Left Antenna (elbow joint)
            ctx.moveTo(-1.5*s, -5*s);
            ctx.lineTo(-4*s, -7*s + twitchL); 
            ctx.lineTo(-6*s, -5*s + twitchL * 5); 
            ctx.stroke();

            // Right Antenna
            ctx.beginPath();
            ctx.moveTo(1.5*s, -5*s);
            ctx.lineTo(4*s, -7*s + twitchR);
            ctx.lineTo(6*s, -5*s + twitchR * 5);
            ctx.stroke();

            // Eyes
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-1.8*s, -5*s, 0.4*s, 0, Math.PI*2);
            ctx.arc(1.8*s, -5*s, 0.4*s, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }

    // --- MAIN LOOP ---
    for(let i=0; i<ANT_COUNT; i++) ants.push(new Ant());

    function animate() {
        ctx.clearRect(0, 0, w, h);
        
        // Draw Faint Watermark
        ctx.save();
        ctx.translate(w/2, h/2);
        ctx.rotate(-Math.PI/12);
        ctx.font = "bold 100px sans-serif";
        ctx.fillStyle = "rgba(0,0,0,0.03)";
        ctx.textAlign = "center";
        ctx.fillText("NIHAN CODE", 0, 0);
        ctx.restore();

        // Update Ants
        ants.forEach(ant => {
            ant.update();
            ant.draw();
        });

        requestAnimationFrame(animate);
    }
    animate();

</script>

</body>
</html>
